/* seller/orders-script.js
   - Loads seller orders from public.orders (RLS enforced)
   - Shows table + stats
   - Modal shows order header + items from public.order_items
   - Allows seller to update order_status
*/

(function () {
  "use strict";

  // ---------- helpers ----------
  const el = (id) => document.getElementById(id);

  function toast(message, type = "info") {
    const t = el("toast");
    const msg = el("toastMessage");
    if (!t || !msg) {
      alert(message);
      return;
    }
    msg.textContent = message;
    t.classList.add("show");
    t.dataset.type = type;
    setTimeout(() => t.classList.remove("show"), 2400);
  }

  function safeText(x) {
    return String(x ?? "");
  }

  function fmtMoney(n) {
    const val = Number(n || 0);
    return `GHS ${val.toFixed(2)}`;
  }

  function fmtDate(iso) {
    if (!iso) return "-";
    try {
      return new Date(iso).toLocaleString();
    } catch {
      return "-";
    }
  }

  function statusClass(status) {
    const s = String(status || "").toLowerCase();
    if (s === "pending") return "order-status status-pending";
    if (s === "processing") return "order-status status-processing";
    if (s === "shipped") return "order-status status-shipped";
    if (s === "delivered") return "order-status status-delivered";
    if (s === "cancelled") return "order-status status-cancelled";
    return "order-status status-pending";
  }

  async function getClient() {
    // Your /js/supabase-config.js creates window.supabase
    if (!window.supabase) throw new Error("Supabase client not found. Check /js/supabase-config.js path.");
    return window.supabase;
  }

  async function requireSeller() {
    const client = await getClient();
    const { data, error } = await client.auth.getSession();
    if (error) throw error;

    const session = data?.session;
    if (!session?.user) {
      // clean stale local storage
      localStorage.removeItem("authToken");
      localStorage.removeItem("currentUser");
      localStorage.removeItem("sessionExpiry");
      localStorage.removeItem("role");
      window.location.href = "seller-login.html";
      return null;
    }

    // Optional: role check (your login sets role=seller)
    const role = localStorage.getItem("role");
    if (role && role !== "seller") {
      window.location.href = "seller-login.html";
      return null;
    }

    // Sentry user identify
    if (typeof Sentry !== "undefined") {
      Sentry.setUser({ id: session.user.id, email: session.user.email, role: "seller" });
      Sentry.addBreadcrumb({ category: "navigation", message: "Seller orders page viewed", level: "info" });
    }

    // Fill name top bar (if present)
    const nameEl = el("userName");
    if (nameEl) nameEl.textContent = (session.user.email || "Seller").split("@")[0];
    const storeNameEl = el("storeName");
    if (storeNameEl) storeNameEl.textContent = "My Store";

    return session.user;
  }

  // ---------- state ----------
  let USER = null;
  let ORDERS = [];

  // ---------- data loading ----------
  async function fetchOrders({ status = "", sortBy = "newest" } = {}) {
    const client = await getClient();

    let query = client
      .from("orders")
      .select("id, order_number, customer_id, seller_id, total_amount, order_status, payment_status, created_at, updated_at")
      .eq("seller_id", USER.id);

    if (status) query = query.eq("order_status", status);

    // Sort
    if (sortBy === "oldest") query = query.order("created_at", { ascending: true });
    else if (sortBy === "highest") query = query.order("total_amount", { ascending: false });
    else if (sortBy === "lowest") query = query.order("total_amount", { ascending: true });
    else query = query.order("created_at", { ascending: false }); // newest

    const { data, error } = await query;
    if (error) throw error;

    ORDERS = data || [];
    return ORDERS;
  }

  async function fetchOrderItems(orderId) {
    const client = await getClient();
    const { data, error } = await client
      .from("order_items")
      .select("id, order_id, product_id, product_name, product_sku, quantity, unit_price, subtotal, created_at")
      .eq("order_id", orderId)
      .order("created_at", { ascending: true });

    if (error) throw error;
    return data || [];
  }

  // ---------- rendering ----------
  function renderStats() {
    el("totalOrders").textContent = ORDERS.length;

    const pending = ORDERS.filter(o => (o.order_status || "").toLowerCase() === "pending").length;
    const processing = ORDERS.filter(o => (o.order_status || "").toLowerCase() === "processing").length;
    const completed = ORDERS.filter(o => {
      const s = (o.order_status || "").toLowerCase();
      return s === "delivered" || s === "completed";
    }).length;

    el("pendingOrders").textContent = pending;
    el("processingOrders").textContent = processing;
    el("completedOrders").textContent = completed;

    // Sidebar badge (if present)
    const orderCount = el("orderCount");
    if (orderCount) orderCount.textContent = String(ORDERS.length);
  }

  function renderOrdersTable() {
    const container = el("ordersContainer");
    if (!container) return;

    if (!ORDERS.length) {
      container.innerHTML = `
        <div class="empty-state">
          <div class="empty-icon">ðŸ›’</div>
          <h3>No orders yet</h3>
          <p>Your store has no orders matching the current filter.</p>
        </div>
      `;
      return;
    }

    container.innerHTML = `
      <div class="orders-table-container">
        <table class="orders-table">
          <thead>
            <tr>
              <th>Order #</th>
              <th>Customer</th>
              <th>Items</th>
              <th>Total</th>
              <th>Status</th>
              <th>Date</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            ${ORDERS.map(o => `
              <tr>
                <td class="order-id">${safeText(o.order_number || (o.id || "").slice(0, 8))}</td>
                <td>
                  <div class="order-customer">
                    <span class="customer-name">${safeText((o.customer_id || "").slice(0, 8))}</span>
                    <span class="customer-contact">Customer ID</span>
                  </div>
                </td>
                <td class="order-items">View in details</td>
                <td class="order-total">${fmtMoney(o.total_amount)}</td>
                <td><span class="${statusClass(o.order_status)}">${safeText(o.order_status || "pending")}</span></td>
                <td class="order-date">${fmtDate(o.created_at)}</td>
                <td>
                  <div class="order-actions">
                    <button class="btn-view" data-order-id="${o.id}">View</button>
                  </div>
                </td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      </div>
    `;

    // wire buttons
    container.querySelectorAll(".btn-view").forEach(btn => {
      btn.addEventListener("click", async () => {
        const orderId = btn.getAttribute("data-order-id");
        await openOrderModal(orderId);
      });
    });
  }

  // ---------- modal ----------
  async function openOrderModal(orderId) {
    const modal = el("orderDetailModal");
    const content = el("orderDetailContent");
    const closeBtn = el("closeModal");
    if (!modal || !content) return;

    const order = ORDERS.find(o => o.id === orderId);
    if (!order) {
      toast("Order not found", "error");
      return;
    }

    modal.classList.add("show");

    // close handlers
    const close = () => modal.classList.remove("show");
    if (closeBtn) closeBtn.onclick = close;
    modal.onclick = (e) => { if (e.target === modal) close(); };

    content.innerHTML = `
      <div class="order-detail-section">
        <h4>Order Summary</h4>
        <div class="detail-grid">
          <div class="detail-item">
            <span class="detail-label">Order #</span>
            <span class="detail-value">${safeText(order.order_number || order.id.slice(0, 8))}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Created</span>
            <span class="detail-value">${fmtDate(order.created_at)}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Payment Status</span>
            <span class="detail-value">${safeText(order.payment_status || "unpaid")}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Order Status</span>
            <span class="detail-value">${safeText(order.order_status || "pending")}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Total Amount</span>
            <span class="detail-value">${fmtMoney(order.total_amount)}</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Customer</span>
            <span class="detail-value">${safeText(order.customer_id || "").slice(0, 8)}</span>
          </div>
        </div>
      </div>

      <div class="order-detail-section">
        <h4>Items</h4>
        <div id="itemsLoading">Loading items...</div>
        <div class="order-items-list" id="itemsList" style="display:none;"></div>
      </div>

      <div class="order-detail-section status-update-section">
        <h4>Update Order Status</h4>
        <select class="status-select" id="statusSelect">
          <option value="pending">Pending</option>
          <option value="processing">Processing</option>
          <option value="shipped">Shipped</option>
          <option value="delivered">Delivered</option>
          <option value="cancelled">Cancelled</option>
        </select>

        <button class="btn-update-status" id="updateStatusBtn">
          Update Status
        </button>

        <p style="margin-top:10px; font-size:0.85rem; color:#666;">
          Updates are protected by RLS. If policy blocks it, youâ€™ll see an error.
        </p>
      </div>
    `;

    // set current status
    const statusSelect = el("statusSelect");
    if (statusSelect) statusSelect.value = String(order.order_status || "pending").toLowerCase();

    // load items
    try {
      const items = await fetchOrderItems(orderId);

      const itemsLoading = el("itemsLoading");
      const itemsList = el("itemsList");
      if (itemsLoading) itemsLoading.style.display = "none";
      if (!itemsList) return;

      itemsList.style.display = "flex";
      itemsList.innerHTML = items.length
        ? items.map(it => `
            <div class="order-item-card">
              <div class="item-image">ðŸ“¦</div>
              <div class="item-details">
                <div class="item-name">${safeText(it.product_name || "Product")}</div>
                <div class="item-price">
                  Qty: ${Number(it.quantity || 0)} â€¢ Unit: ${fmtMoney(it.unit_price)} â€¢ Subtotal: ${fmtMoney(it.subtotal)}
                </div>
                ${it.product_sku ? `<div class="item-price">SKU: ${safeText(it.product_sku)}</div>` : ""}
              </div>
            </div>
          `).join("")
        : `<div style="color:#666;">No items found for this order.</div>`;
    } catch (err) {
      console.error(err);
      toast(err.message || "Failed to load order items", "error");
      const itemsLoading = el("itemsLoading");
      if (itemsLoading) itemsLoading.textContent = "Could not load items.";
    }

    // wire update status
    const updateBtn = el("updateStatusBtn");
    if (updateBtn) {
      updateBtn.onclick = async () => {
        try {
          updateBtn.disabled = true;
          updateBtn.textContent = "Updating...";

          const newStatus = (el("statusSelect")?.value || "pending").toLowerCase();
          await updateOrderStatus(orderId, newStatus);

          toast("Order status updated âœ…", "success");
          close(); // close modal
          await refresh(); // reload list
        } catch (err) {
          console.error(err);
          toast(err.message || "Failed to update status", "error");
        } finally {
          updateBtn.disabled = false;
          updateBtn.textContent = "Update Status";
        }
      };
    }
  }

  async function updateOrderStatus(orderId, newStatus) {
    const client = await getClient();

    // Your policy "Orders: seller update own" allows seller_id = auth.uid()
    const { error } = await client
      .from("orders")
      .update({ order_status: newStatus, updated_at: new Date().toISOString() })
      .eq("id", orderId);

    if (error) throw error;

    // keep local state in sync
    const idx = ORDERS.findIndex(o => o.id === orderId);
    if (idx >= 0) ORDERS[idx].order_status = newStatus;
  }

  // ---------- filter wiring ----------
  function wireFilters() {
    const statusFilter = el("statusFilter");
    const sortBy = el("sortBy");

    const onChange = async () => {
      await refresh();
    };

    if (statusFilter) statusFilter.addEventListener("change", onChange);
    if (sortBy) sortBy.addEventListener("change", onChange);
  }

  async function refresh() {
    const status = (el("statusFilter")?.value || "").trim().toLowerCase();
    const sortBy = (el("sortBy")?.value || "newest").trim().toLowerCase();

    const container = el("ordersContainer");
    if (container) {
      container.innerHTML = `
        <div class="orders-table-container">
          <div style="padding:24px;">Loading orders...</div>
        </div>
      `;
    }

    ORDERS = await fetchOrders({ status, sortBy });
    renderStats();
    renderOrdersTable();
  }

  // ---------- dropdown + logout ----------
  function wireUserMenu() {
    const btn = el("userMenuBtn");
    const dd = el("userDropdown");
    if (!btn || !dd) return;

    btn.addEventListener("click", () => dd.classList.toggle("show"));
    document.addEventListener("click", (e) => {
      if (!dd.contains(e.target) && !btn.contains(e.target)) dd.classList.remove("show");
    });
  }

  async function wireLogout() {
    const logoutBtn = el("logoutBtn");
    if (!logoutBtn) return;

    logoutBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      try {
        const client = await getClient();
        await client.auth.signOut();

        localStorage.removeItem("authToken");
        localStorage.removeItem("currentUser");
        localStorage.removeItem("sessionExpiry");
        localStorage.removeItem("role");

        if (typeof Sentry !== "undefined") Sentry.setUser(null);

        window.location.href = "seller-login.html";
      } catch (err) {
        console.error(err);
        toast(err.message || "Logout failed", "error");
      }
    });
  }

  // ---------- boot ----------
  async function boot() {
    try {
      USER = await requireSeller();
      if (!USER) return;

      wireFilters();
      wireUserMenu();
      await wireLogout();

      // quick actions
      const addProductBtn = el("addProductBtn");
      if (addProductBtn) addProductBtn.onclick = () => window.location.href = "products.html?action=add";
      const shareStoreBtn = el("shareStoreBtn");
      if (shareStoreBtn) shareStoreBtn.onclick = () => toast("Store share feature coming soon âœ…");

      await refresh();
    } catch (err) {
      console.error("Orders boot error:", err);
      if (typeof Sentry !== "undefined") {
        Sentry.captureException(err, { tags: { error_category: "seller_orders" } });
      }
      window.location.href = "seller-login.html";
    }
  }

  boot();
})();
